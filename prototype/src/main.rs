use stateworks::word_counter;

mod stateworks {
    //! This module contains a very naive and basic implementation of a state machine
    //! structure that will allow the user to count words. There will be no worry about
    //! optimizations at the moment.
    //!
    //! The model to be implemented is a very basic homogeneous iterative synchronous
    //! function state
    //! machine (HISFSM).
    //! The meaning is the following:
    //! - Homogeneous: the user will only be able to send one type of input to the machine,
    //! in this case, chars.
    //! - Iterative: the state machine will work on an iterative fashion. Each iteration,
    //! the user will send a new char to it.
    //! - Synchronous: each time the user sends an input to the machine, the program must
    //! wait for it to finish the calculations for that iteration before continuing to the
    //! next command.
    //! - Function: the only interface between this state machine and the remaining of the
    //! programming world will be through a function. That may not be the case in the
    //! future, where we may want to implement state machines as structs, allowing more
    //! sophisticated interactions and APIs.
    //!
    //! That limitations will make it much simpler to implement. Later, we try to add more
    //! complexity and optimizations.

    use std::collections::{HashMap, HashSet};

    // each state machine defines a set of virtual inputs and virtual outputs
    // Both are simply enums:

    // Word counter hard coded implementation

    // For the word counter, all of those VI will be read from the real input of an
    // iterator. In other words, all of them are generated by the action of an input string
    // (from the function input), a preprocessing of this string and transformation of each
    // char into the VI.
    //
    // Who decides when the input will be triggered? the programmer.
    #[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
    enum VirtualInput {
        /// Read anything that is not an alphanumeric char.
        ReadOther,
        ReadAlphanumeric,
        // /// Read the last char of the file
        //ReadEOF,
        // TODO: think about it: should I create an Always VI to represent a condition that
        // accepts any substate of the VI set? Or should I implement that in the Condition
        // struct?
        Always,
    }

    // At the moment, I am not worried about the categorization of useful IO-objects. I am
    // only defining the simplest subset necessary for this state machine to work. For
    // example, in this situation, it is interesting to define a generic Counter object,
    // which could be used by any project.
    #[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
    enum VirtualOutput {
        IncrementCounter,
        // /// This action will be triggered by any input action of the type ReadEOF.
        // /// After generating this output, the return of the function will be triggered.
        //Return,
    }

    #[derive(Debug, Clone)]
    struct Condition {
        // At the moment, only a bunch of AND conditions will be enough. Also, maybe storing
        // them as vector is not the best choice, because we will make set operations with
        // them. But that is something for the future..
        and: HashSet<VirtualInput>,
    }

    #[derive(Debug, PartialEq, Eq, Hash, Clone)]
    enum State {
        Init,
        InWord,
        OutWord,
    }

    #[derive(Debug, Clone)]
    struct StateSpec<'a> {
        name: &'a str,
        entry_actions: Vec<VirtualOutput>,
        exit_actions: Vec<VirtualOutput>,
        input_actions: Vec<(Condition, VirtualOutput)>,
        transitions: Vec<(Condition, State)>,
    }

    #[derive(Debug)]
    struct StateMachine<'a> {
        current_state: State,
        states: HashMap<State, StateSpec<'a>>,
        // Input actions that will be executed always, regardless of the current state
        always: Vec<(Condition, VirtualOutput)>,
    }

    // In the future, our intention is that all of the code generated to run the state
    // machine will be automatically generated, and it will not be intended to edit it
    // directly. Only the high level specification of the state machine should be edited.
    impl<'a> StateMachine<'a> {
        fn new() -> Self {
            let init = StateSpec {
                name: "init",
                entry_actions: vec![],
                exit_actions: vec![],
                input_actions: vec![],
                transitions: vec![(
                    Condition {
                        and: HashSet::from_iter(vec![VirtualInput::Always]),
                    },
                    State::InWord,
                )],
            };
            let in_word = StateSpec {
                name: "in_word",
                entry_actions: vec![],
                exit_actions: vec![],
                input_actions: vec![],
                transitions: vec![
                    (
                        Condition {
                            and: HashSet::from_iter(vec![VirtualInput::ReadOther]),
                        },
                        State::OutWord,
                    ),
                    (
                        Condition {
                            and: HashSet::from_iter(vec![VirtualInput::ReadAlphanumeric]),
                        },
                        State::InWord,
                    ),
                ],
            };

            let out_word = StateSpec {
                name: "out_word",
                entry_actions: vec![],
                exit_actions: vec![],
                input_actions: vec![(
                    Condition {
                        and: HashSet::from_iter(vec![VirtualInput::ReadAlphanumeric]),
                    },
                    VirtualOutput::IncrementCounter,
                )],
                transitions: vec![
                    (
                        Condition {
                            and: HashSet::from_iter(vec![VirtualInput::ReadOther]),
                        },
                        State::OutWord,
                    ),
                    (
                        Condition {
                            and: HashSet::from_iter(vec![VirtualInput::ReadAlphanumeric]),
                        },
                        State::InWord,
                    ),
                ],
            };

            StateMachine {
                current_state: State::Init,
                states: HashMap::from_iter(vec![
                    (State::Init, init),
                    (State::InWord, in_word),
                    (State::OutWord, out_word),
                ]),
                always: vec![/*(
                    Condition {
                        and: HashSet::from_iter(vec![VirtualInput::ReadEOF]),
                    },
                    VirtualOutput::Return,
                )*/],
            }
        }

        fn emit_virtual_output(&mut self, vo: VirtualOutput) {}
        // in this case, it is very simple to emit each VI at time, but in the future, may
        // be interesting to investigate the approach of registering the VIs for the input
        // preprocessor and then emit all of them at once.
        fn emit_virtual_input(&mut self, vi: VirtualInput) {
            // here, we start the cycle for the VFSM execution model. For this simplified
            // state machine implementation, always, at this point, the VFSM will be in the
            // idle state, waiting for VIs to come.
            let current_state = self.states[&self.current_state].clone(); // TODO optimize
                                                                          // that clone

            let condition = Condition {
                and: HashSet::from_iter(vec![vi]),
            };

            // check for input actions

            for (inpus_action_condition, vo) in current_state.input_actions {
                if condition.and.is_subset(&inpus_action_condition.and) {
                    //TODO this may trigger other virtual inputs, need to handle this...
                    // One aspect is: should I gather some virtual outputs from the input
                    // actions and only them execute them or should I execute one by one?
                    // What are the pros and cons of each approach? is it interesting to
                    // have models for both? are there use cases for both approaches or they
                    // are equivalent?
                    //
                    // For this current state machine, VO are not able to emit VI, thus, we
                    // do not need to worry about that right now, but for more complex state
                    // machines, I want to handle this situation.

                    // execute the input action
                    self.emit_virtual_output(vo);
                }
            }

            // check for transition conditions
            for (transition_condition, next_state) in current_state.transitions {
                // TODO continue from here...
                // it is interesting to decouple the execution model from the emission of
                // VI
            }
        }

        // This method will make the interface between the state machine with the IO from
        // function.
        fn consume_char(&mut self, c: char) {
            match c {
                c if c.is_alphanumeric() => self.emit_virtual_input(VirtualInput::ReadAlphanumeric),
                _ => self.emit_virtual_input(VirtualInput::ReadOther),
            };
        }
    }

    pub fn word_counter(text: &str) -> u32 {
        let state_machine = StateMachine::new();

        // process the input into
    }
}

/// Counts the number of words in a given string. Each word is separated by white spaces.
///
/// This implementation will be used as reference for the state machine implementation.
fn word_counter_reference(text: &str) -> u32 {
    text.split_whitespace().count() as u32
}

/**
 * There are some considerations to do about this use case. First, we need to define the IO
 * interface between the programming language and the state machine. The interface will be
 * the signature of the function. Thus, our state machine will receive a text and will
 * return an u32.
 */
fn word_counter_state_machine(text: &str) -> u32 {
    word_counter(text)
}

fn main() {
    println!("Hello, world!");
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! test_word_counter {
        ($name:ident, $func:ident) => {
            mod $name {
                use super::*;

                #[test]
                fn should_count_0_words() {
                    assert_eq!($func(""), 0);
                    assert_eq!($func("    "), 0);
                    assert_eq!($func("\n\t"), 0);
                }

                #[test]
                fn should_count_1_words() {
                    assert_eq!($func("i"), 1);
                    assert_eq!($func("  hi  "), 1);
                    assert_eq!($func("\n\thello    \n\n"), 1);
                }

                #[test]
                fn should_count_2_words() {
                    assert_eq!($func("i a"), 2);
                    assert_eq!($func("  hi there  "), 2);
                    assert_eq!($func("\n\thello\nworld\n"), 2);
                }

                #[test]
                fn should_count_5_words() {
                    assert_eq!($func("This text has 5 words.\n"), 5);
                }
            }
        };
    }

    test_word_counter!(test_word_counter_reference, word_counter_reference);
    test_word_counter!(test_word_counter_state_machine, word_counter_state_machine);
}
