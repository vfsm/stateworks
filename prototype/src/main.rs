mod stateworks {
    //! This module contains a very naive and basic implementation of a state machine
    //! structure that will allow the user to count words. There will be no worry about
    //! optimizations at the moment.
    //!
    //! The model to be implemented is a very basic homogeneous iterative synchronous
    //! function state
    //! machine (HISFSM).
    //! The meaning is the following:
    //! - Homogeneous: the user will only be able to send one type of input to the machine,
    //! in this case, chars.
    //! - Iterative: the state machine will work on an iterative fashion. Each iteration,
    //! the user will send a new char to it.
    //! - Synchronous: each time the user sends an input to the machine, the program must
    //! wait for it to finish the calculations for that iteration before continuing to the
    //! next command.
    //! - Function: the only interface between this state machine and the remaining of the
    //! programming world will be through a function. That may not be the case in the
    //! future, where we may want to implement state machines as structs, allowing more
    //! sophisticated interactions and APIs.
    //!
    //! That limitations will make it much simpler to implement. Later, we try to add more
    //! complexity and optimizations.

    use std::collections::HashMap;

    // each state machine defines a set of virtual inputs and virtual outputs
    // Both are simply enums:

    // Word counter hard coded implementation

    // For the word counter, all of those VI will be read from the real input of an
    // iterator. In other words, all of them are generated by the action of an input string
    // (from the function input), a preprocessing of this string and transformation of each
    // char into the VI.
    //
    // Who decides when the input will be triggered? the programmer.
    enum VirtualInput {
        /// Read anything that is not an alphanumeric char.
        ReadOther,
        ReadAlphanumeric,
        /// Read the last char of the file
        ReadEOF,
        // TODO: think about it: should I create an Always VI to represent a condition that
        // accepts any substate of the VI set? Or should I implement that in the Condition
        // struct?
        Always,
    }

    // At the moment, I am not worried about the categorization of useful IO-objects. I am
    // only defining the simplest subset necessary for this state machine to work. For
    // example, in this situation, it is interesting to define a generic Counter object,
    // which could be used by any project.
    enum VirtualOutput {
        IncrementCounter,
        /// This action will be triggered by any input action of the type ReadEOF.
        /// After generating this output, the return of the function will be triggered.
        Return,
    }

    struct Condition {
        // At the moment, only a bunch of AND conditions will be enough. Also, maybe storing
        // them as vector is not the best choice, because we will make set operations with
        // them. But that is something for the future..
        and: Vec<VirtualInput>,
    }

    enum State {
        Init,
        InWord,
        OutWord,
    }

    struct StateSpec<'a> {
        name: &'a str,
        entry_actions: Vec<VirtualOutput>,
        exit_actions: Vec<VirtualOutput>,
        input_actions: Vec<(Condition, VirtualOutput)>,
        transitions: Vec<(Condition, State)>,
    }

    struct StateMachine<'a> {
        current_state: State,
        states: Vec<StateSpec<'a>>,
        always: Vec<(Condition, VirtualOutput)>,
    }

    // In the future, our intention is that all of the code generated to run the state
    // machine will be automatically generated, and it will not be intended to edit it
    // directly. Only the high level specification of the state machine should be edited.
    impl<'a> StateMachine<'a> {
        fn new() -> Self {
            let init = StateSpec {
                name: "init",
                entry_actions: vec![],
                exit_actions: vec![],
                input_actions: vec![],
                transitions: vec![(
                    Condition {
                        and: vec![VirtualInput::Always],
                    },
                    State::InWord,
                )],
            };
            let in_word = StateSpec {
                name: "in_word",
                entry_actions: vec![],
                exit_actions: vec![],
                input_actions: vec![],
                transitions: vec![
                    (
                        Condition {
                            and: vec![VirtualInput::ReadOther],
                        },
                        State::OutWord,
                    ),
                    (
                        Condition {
                            and: vec![VirtualInput::ReadAlphanumeric],
                        },
                        State::InWord,
                    ),
                ],
            };

            let out_word = StateSpec {
                name: "out_word",
                entry_actions: vec![],
                exit_actions: vec![],
                input_actions: vec![(
                    Condition {
                        and: vec![VirtualInput::ReadAlphanumeric],
                    },
                    VirtualOutput::IncrementCounter,
                )],
                transitions: vec![
                    (
                        Condition {
                            and: vec![VirtualInput::ReadOther],
                        },
                        State::OutWord,
                    ),
                    (
                        Condition {
                            and: vec![VirtualInput::ReadAlphanumeric],
                        },
                        State::InWord,
                    ),
                ],
            };

            StateMachine {
                current_state: State::Init,
                states: vec![init, in_word, out_word],
                always: vec![(
                    Condition {
                        and: vec![VirtualInput::ReadEOF],
                    },
                    VirtualOutput::Return,
                )],
            }
            // TODO continue from here...
        }
    }
}

/// Counts the number of words in a given string. Each word is separated by white spaces.
///
/// This implementation will be used as reference for the state machine implementation.
fn word_counter_reference(text: &str) -> u32 {
    text.split_whitespace().count() as u32
}

/**
 * There are some considerations to do about this use case. First, we need to define the IO
 * interface between the programming language and the state machine. The interface will be
 * the signature of the function. Thus, our state machine will receive a text and will
 * return an u32.
 */
fn word_counter_state_machine(text: &str) -> u32 {
    todo!()
}

fn main() {
    println!("Hello, world!");
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! test_word_counter {
        ($name:ident, $func:ident) => {
            mod $name {
                use super::*;

                #[test]
                fn should_count_0_words() {
                    assert_eq!($func(""), 0);
                    assert_eq!($func("    "), 0);
                    assert_eq!($func("\n\t"), 0);
                }

                #[test]
                fn should_count_1_words() {
                    assert_eq!($func("i"), 1);
                    assert_eq!($func("  hi  "), 1);
                    assert_eq!($func("\n\thello    \n\n"), 1);
                }

                #[test]
                fn should_count_2_words() {
                    assert_eq!($func("i a"), 2);
                    assert_eq!($func("  hi there  "), 2);
                    assert_eq!($func("\n\thello\nworld\n"), 2);
                }

                #[test]
                fn should_count_5_words() {
                    assert_eq!($func("This text has 5 words.\n"), 5);
                }
            }
        };
    }

    test_word_counter!(test_word_counter_reference, word_counter_reference);
    test_word_counter!(test_word_counter_state_machine, word_counter_state_machine);
}
